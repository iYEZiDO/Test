<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pull the Pin - 1000 Level</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header class="topbar">
    <div class="branding">
      <h1>Pull the Pin</h1>
      <p>1000 echte Puzzle-Level</p>
    </div>
    <div class="progress">
      <div class="progress-item">Level: <span id="levelLabel"></span>/1000</div>
      <div class="progress-item">Coins: <span id="coinLabel"></span></div>
      <div class="progress-item">Sterne: <span id="starLabel"></span></div>
      <div class="progress-item">Züge: <span id="moveLabel"></span></div>
    </div>
    <div class="actions">
      <button id="btnHint">Hint</button>
      <button id="btnReset">Reset</button>
      <button id="btnNext">Nächstes Level</button>
    </div>
  </header>

  <main class="layout">
    <section class="sidebar">
      <h2>Regeln</h2>
      <ul>
        <li>Ziehe Pins in der richtigen Reihenfolge.</li>
        <li>Bring den Helden sicher zur Schatztruhe.</li>
        <li>Wasser löscht Lava, Gas entzündet sich bei Feuer.</li>
        <li>Begrenzte Züge ab Level 300.</li>
        <li>Mehrstufige Mehrraum-Puzzles ab Level 600.</li>
        <li>Meister-Level ab 900: perfekter Ablauf nötig.</li>
      </ul>
      <div class="hint-box" id="hintBox"></div>
    </section>
    <section class="game-area">
      <canvas id="gameCanvas" width="900" height="640" aria-label="Spielfeld"></canvas>
      <div class="status" id="statusText"></div>
    </section>
  </main>

  <script>
    const LEVEL_COUNT = 1000;
    const CYCLE = 50;
    const CELL = 32;
    const MATERIALS = {
      EMPTY: 'empty',
      WALL: 'wall',
      HERO: 'hero',
      TREASURE: 'treasure',
      WATER: 'water',
      LAVA: 'lava',
      GAS: 'gas',
      SAND: 'sand',
      STONE: 'stone',
      FIRE: 'fire',
      ENEMY: 'enemy'
    };

    const COLORS = {
      [MATERIALS.EMPTY]: '#1f2937',   // etwas heller
  [MATERIALS.WALL]: '#000000',    // richtig schwarz
  [MATERIALS.HERO]: '#38bdf8',
  [MATERIALS.TREASURE]: '#fbbf24',
  [MATERIALS.WATER]: '#0ea5e9',
  [MATERIALS.LAVA]: '#fb7185',
  [MATERIALS.GAS]: '#a855f7',
  [MATERIALS.SAND]: '#f59e0b',
  [MATERIALS.STONE]: '#6b7280',
  [MATERIALS.FIRE]: '#ef4444',
  [MATERIALS.ENEMY]: '#22c55e'
};

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('statusText');
    const hintBox = document.getElementById('hintBox');

    const levelLabel = document.getElementById('levelLabel');
    const coinLabel = document.getElementById('coinLabel');
    const starLabel = document.getElementById('starLabel');
    const moveLabel = document.getElementById('moveLabel');

    const btnHint = document.getElementById('btnHint');
    const btnReset = document.getElementById('btnReset');
    const btnNext = document.getElementById('btnNext');

    let state = {
      levelIndex: 1,
      coins: 0,
      stars: 0,
      moveLimit: Infinity,
      movesUsed: 0,
      pulledPins: [],
      grid: null,
      pins: [],
      hero: null,
      treasure: null,
      enemies: [],
      won: false,
      lost: false,
      hintCost: 15
    };

    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function createGrid(width, height) {
      const cells = new Array(width * height).fill(null).map(() => ({ material: MATERIALS.EMPTY, fireTicks: 0 }));
      const hBlocks = Array.from({ length: width }, () =>
        Array.from({ length: height - 1 }, () => ({ solid: false, pin: null }))
      );
      const vBlocks = Array.from({ length: width - 1 }, () =>
        Array.from({ length: height }, () => ({ solid: false, pin: null }))
      );
      return { width, height, cells, hBlocks, vBlocks };
    }

    function idx(grid, x, y) {
      return y * grid.width + x;
    }

    function setCell(grid, x, y, material, extra = {}) {
      grid.cells[idx(grid, x, y)] = { material, ...extra };
    }

    function getCell(grid, x, y) {
      return grid.cells[idx(grid, x, y)];
    }

    function addWall(grid, x, y, orientation, pin = null) {
      if (orientation === 'h') {
        grid.hBlocks[x][y] = { solid: true, pin };
      } else {
        grid.vBlocks[x][y] = { solid: true, pin };
      }
    }

    function isBlocked(grid, x1, y1, x2, y2) {
      if (x2 < 0 || x2 >= grid.width || y2 < 0 || y2 >= grid.height) return true;
      if (x1 === x2 && y1 === y2) return false;
      if (x1 === x2) {
        const y = Math.min(y1, y2);
        const block = grid.hBlocks[x1][y];
        return block.solid;
      }
      if (y1 === y2) {
        const x = Math.min(x1, x2);
        const block = grid.vBlocks[x][y1];
        return block.solid;
      }
      return true;
    }

    function addBoundaryWalls(grid) {
      for (let x = 0; x < grid.width; x++) {
        addWall(grid, x, 0, 'h');
        addWall(grid, x, grid.height - 1, 'h');
      }
      for (let y = 0; y < grid.height; y++) {
        addWall(grid, 0, y, 'v');
        addWall(grid, grid.width - 1, y, 'v');
      }
    }

    function createPin(id, orientation, x, y, label) {
      return { id, orientation, x, y, label, pulled: false };
    }

    function attachPin(grid, pin) {
      addWall(grid, pin.x, pin.y, pin.orientation, pin.id);
    }

    function pullPin(pinId) {
      const pin = state.pins.find(p => p.id === pinId);
      if (!pin || pin.pulled || state.won || state.lost) return;
      if (state.movesUsed >= state.moveLimit) return;
      state.movesUsed += 1;
      pin.pulled = true;
      state.pulledPins.push(pinId);
      if (pin.orientation === 'h') {
        state.grid.hBlocks[pin.x][pin.y] = { solid: false, pin: null };
      } else {
        state.grid.vBlocks[pin.x][pin.y] = { solid: false, pin: null };
      }
      updateMoveLabel();
    }

    function seededChoice(rand, list) {
      return list[Math.floor(rand() * list.length)];
    }

    function generateLevel(levelIndex) {
      const rand = mulberry32(levelIndex * 1337);
      const width = 18;
      const height = 16;
      const grid = createGrid(width, height);
      addBoundaryWalls(grid);

      const cycle = Math.floor((levelIndex - 1) / CYCLE) + 1;
      const difficulty = cycle + Math.floor(levelIndex / 100);
      const chamberCount = Math.min(6, 3 + Math.floor(difficulty / 3));
      const columnSplit = levelIndex >= 600 ? 2 : 1;
      const chamberHeight = Math.floor((height - 2) / chamberCount);
      const pins = [];
      const hintOrder = [];

      // Draw vertical walls for columns
      if (columnSplit === 2) {
        const splitX = Math.floor(width / 2);
        for (let y = 1; y < height - 1; y++) {
          addWall(grid, splitX, y, 'v');
        }
      }

      // Place chambers stacked vertically for each column
      for (let c = 0; c < chamberCount; c++) {
        const yStart = 1 + c * chamberHeight;
        const yEnd = c === chamberCount - 1 ? height - 2 : yStart + chamberHeight - 1;
        if (c < chamberCount - 1) {
          // Add horizontal pin wall
          const pinId = `pin-${c}`;
          const px = Math.floor(width / 2) - (columnSplit === 2 ? 3 : 0);
          const py = yEnd;
          const label = String.fromCharCode(65 + c);
          const pin = createPin(pinId, 'h', px, py, label);
          pins.push(pin);
          hintOrder.push(pinId);
          attachPin(grid, pin);
          // Fill rest of wall as solid without pin for stability
          for (let x = 1; x < width - 1; x++) {
            if (x === px) continue;
            addWall(grid, x, py, 'h');
          }
        }
      }

      // Multi-room connectors after 600
      if (columnSplit === 2) {
        const connectorLevels = Math.max(2, Math.floor(difficulty / 2));
        for (let i = 0; i < connectorLevels; i++) {
          const y = 2 + (i * 3) % (height - 4);
          const pinId = `cross-${i}`;
          const pin = createPin(pinId, 'v', Math.floor(width / 2), y, `X${i + 1}`);
          pins.push(pin);
          hintOrder.splice(i + 1, 0, pinId);
          attachPin(grid, pin);
        }
      }

      // Place hero and treasure
      const heroPos = { x: Math.floor(width / 2), y: 2 };
      setCell(grid, heroPos.x, heroPos.y, MATERIALS.HERO);
      const treasurePos = { x: Math.floor(width / 2), y: height - 3 };
      setCell(grid, treasurePos.x, treasurePos.y, MATERIALS.TREASURE);

      // Add hazards and materials per chamber
      const materials = [MATERIALS.WATER, MATERIALS.LAVA, MATERIALS.GAS, MATERIALS.SAND];
      for (let c = 1; c < chamberCount - 1; c++) {
        const yStart = 1 + c * chamberHeight;
        const yEnd = c === chamberCount - 1 ? height - 2 : yStart + chamberHeight - 1;
        const fillMaterial = seededChoice(rand, materials);
        const count = 4 + Math.floor(rand() * 6) + c;
        for (let n = 0; n < count; n++) {
          const x = 2 + Math.floor(rand() * (width - 4));
          const y = yStart + 1 + Math.floor(rand() * Math.max(1, yEnd - yStart - 1));
          const cell = getCell(grid, x, y);
          if (cell.material === MATERIALS.EMPTY) {
            setCell(grid, x, y, fillMaterial, { fireTicks: fillMaterial === MATERIALS.FIRE ? 6 : 0 });
          }
        }
      }

      // Enemies grow with difficulty
      const enemyCount = Math.min(6, Math.floor(difficulty / 2));
      const enemies = [];
      for (let i = 0; i < enemyCount; i++) {
        const x = 2 + Math.floor(rand() * (width - 4));
        const y = 2 + Math.floor(rand() * (height - 4));
        const cell = getCell(grid, x, y);
        if (cell.material === MATERIALS.EMPTY) {
          setCell(grid, x, y, MATERIALS.ENEMY, { dir: rand() > 0.5 ? 1 : -1 });
          enemies.push({ x, y, dir: rand() > 0.5 ? 1 : -1 });
        }
      }

      const moveLimit = levelIndex >= 300 ? Math.max(3, 8 - Math.floor((levelIndex - 300) / 100)) : Infinity;
      const reward = 10 + Math.floor(difficulty * 1.5);
      const hintPins = hintOrder.slice(0, Math.min(5, hintOrder.length)).map(id => pins.find(p => p.id === id)?.label || '');

      return {
        grid,
        pins,
        hero: heroPos,
        treasure: treasurePos,
        enemies,
        moveLimit,
        reward,
        hintText: `Empfohlene Pins: ${hintPins.join(' → ') || 'frei wählbar'}`,
        levelIndex
      };
    }

    function resetLevel() {
      const { levelIndex } = state;
      const level = generateLevel(levelIndex);
      state.grid = level.grid;
      state.pins = level.pins;
      state.hero = level.hero;
      state.treasure = level.treasure;
      state.enemies = level.enemies;
      state.moveLimit = level.moveLimit;
      state.movesUsed = 0;
      state.pulledPins = [];
      state.won = false;
      state.lost = false;
      state.hintText = level.hintText;
      updateLabels();
      statusText.textContent = '';
      draw();
    }

    function updateLabels() {
      levelLabel.textContent = state.levelIndex;
      coinLabel.textContent = state.coins;
      starLabel.textContent = state.stars;
      updateMoveLabel();
      hintBox.textContent = state.hintText || '';
    }

    function updateMoveLabel() {
      moveLabel.textContent = state.moveLimit === Infinity ? '∞' : `${state.movesUsed}/${state.moveLimit}`;
    }

    function saveProgress() {
      localStorage.setItem('pullpin-progress', JSON.stringify({
        levelIndex: state.levelIndex,
        coins: state.coins,
        stars: state.stars
      }));
    }

    function loadProgress() {
      try {
        const data = JSON.parse(localStorage.getItem('pullpin-progress'));
        if (data) {
          state.levelIndex = Math.min(LEVEL_COUNT, data.levelIndex || 1);
          state.coins = data.coins || 0;
          state.stars = data.stars || 0;
        }
      } catch (e) {
        console.warn('Kein Speicherstand geladen', e);
      }
    }

    function drawGrid() {
      const { grid } = state;
      ctx.fillStyle = '#020617';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'rgba(148,163,184,0.1)';
      for (let x = 0; x < grid.width; x++) {
        for (let y = 0; y < grid.height; y++) {
          ctx.strokeRect(x * CELL, y * CELL, CELL, CELL);
        }
      }
      for (let y = 0; y < grid.height; y++) {
        for (let x = 0; x < grid.width; x++) {
          const cell = getCell(grid, x, y);
          ctx.fillStyle = COLORS[cell.material];
          ctx.fillRect(x * CELL, y * CELL, CELL - 1, CELL - 1);
          if (cell.material === MATERIALS.HERO) {
            ctx.fillStyle = '#0ea5e9';
            ctx.fillRect(x * CELL + 6, y * CELL + 6, CELL - 12, CELL - 12);
          }
          if (cell.material === MATERIALS.TREASURE) {
            ctx.fillStyle = '#f59e0b';
            ctx.fillRect(x * CELL + 4, y * CELL + 4, CELL - 8, CELL - 8);
          }
          if (cell.material === MATERIALS.ENEMY) {
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(x * CELL + 6, y * CELL + 6, CELL - 12, CELL - 12);
          }
        }
      }

      // Draw walls
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 2;
      const g = grid;
      for (let x = 0; x < g.width; x++) {
        for (let y = 0; y < g.height - 1; y++) {
          const block = g.hBlocks[x][y];
          if (block.solid) {
            ctx.beginPath();
            ctx.moveTo(x * CELL, (y + 1) * CELL);
            ctx.lineTo((x + 1) * CELL, (y + 1) * CELL);
            ctx.strokeStyle = block.pin ? '#f472b6' : '#94a3b8';
            ctx.stroke();
            if (block.pin) drawPinLabel(x * CELL + CELL / 2, (y + 1) * CELL - 6, block.pin);
          }
        }
      }
      for (let x = 0; x < g.width - 1; x++) {
        for (let y = 0; y < g.height; y++) {
          const block = g.vBlocks[x][y];
          if (block.solid) {
            ctx.beginPath();
            ctx.moveTo((x + 1) * CELL, y * CELL);
            ctx.lineTo((x + 1) * CELL, (y + 1) * CELL);
            ctx.strokeStyle = block.pin ? '#f472b6' : '#94a3b8';
            ctx.stroke();
            if (block.pin) drawPinLabel((x + 1) * CELL - 6, y * CELL + CELL / 2, block.pin, true);
          }
        }
      }
    }

    function drawPinNodes() {
      ctx.save();
      ctx.fillStyle = '#f472b6';
      for (const pin of state.pins) {
        const cx = pin.orientation === 'h' ? pin.x * CELL + CELL / 2 : (pin.x + 1) * CELL;
        const cy = pin.orientation === 'h' ? (pin.y + 1) * CELL : pin.y * CELL + CELL / 2;
        ctx.beginPath();
        ctx.arc(cx, cy, 6, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawPinLabel(x, y, id, vertical = false) {
      ctx.save();
      ctx.fillStyle = '#0ea5e9';
      ctx.font = 'bold 12px Inter, system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.translate(x, y);
      if (vertical) ctx.rotate(-Math.PI / 2);
      ctx.fillText(id.split('-').pop().toUpperCase(), 0, 0);
      ctx.restore();
    }

    function draw() {
      drawGrid();
      drawPinNodes();
      if (state.won) {
        statusText.textContent = 'Gewonnen!';
      } else if (state.lost) {
        statusText.textContent = 'Verloren – versuche es erneut!';
      }
    }

    function tick() {
      if (!state.grid) return;
      if (!state.won && !state.lost) {
        simulateFluids();
        simulateFire();
        moveEnemies();
        moveHero();
        checkGameEnd();
      }
      draw();
      requestAnimationFrame(tick);
    }

    function neighbors(x, y) {
      return [
        { x, y: y - 1 },
        { x: x + 1, y },
        { x, y: y + 1 },
        { x: x - 1, y }
      ];
    }

    function transferMaterial(from, to) {
      const fromCell = getCell(state.grid, from.x, from.y);
      const toCell = getCell(state.grid, to.x, to.y);
      if (toCell.material !== MATERIALS.EMPTY) return false;
      setCell(state.grid, to.x, to.y, fromCell.material, { fireTicks: fromCell.fireTicks || 0 });
      setCell(state.grid, from.x, from.y, MATERIALS.EMPTY, { fireTicks: 0 });
      return true;
    }

    function simulateFluids() {
      const g = state.grid;
      for (let y = g.height - 1; y >= 0; y--) {
        for (let x = 0; x < g.width; x++) {
          const cell = getCell(g, x, y);
          if ([MATERIALS.WATER, MATERIALS.LAVA, MATERIALS.SAND, MATERIALS.GAS].includes(cell.material)) {
            const dir = cell.material === MATERIALS.GAS ? -1 : 1;
            const targets = [
              { x, y: y + dir },
              { x: x + 1, y: y + (dir > 0 ? 0 : -1) },
              { x: x - 1, y: y + (dir > 0 ? 0 : -1) }
            ];
            for (const t of targets) {
              if (!isBlocked(g, x, y, t.x, t.y)) {
                const targetCell = g.cells[idx(g, t.x, t.y)] || { material: MATERIALS.WALL };
                if (targetCell.material === MATERIALS.EMPTY) {
                  transferMaterial({ x, y }, t);
                  break;
                }
              }
            }
          }
        }
      }
    }

    function simulateFire() {
      const g = state.grid;
      for (let y = 0; y < g.height; y++) {
        for (let x = 0; x < g.width; x++) {
          const cell = getCell(g, x, y);
          if (cell.material === MATERIALS.LAVA) {
            for (const n of neighbors(x, y)) {
              if (isBlocked(g, x, y, n.x, n.y)) continue;
              const nb = getCell(g, n.x, n.y);
              if (nb.material === MATERIALS.WATER) {
                setCell(g, x, y, MATERIALS.STONE);
                setCell(g, n.x, n.y, MATERIALS.STONE);
              }
              if (nb.material === MATERIALS.GAS) {
                setCell(g, n.x, n.y, MATERIALS.FIRE, { fireTicks: 6 });
              }
            }
          }
          if (cell.material === MATERIALS.FIRE) {
            const ticks = (cell.fireTicks || 0) - 1;
            if (ticks <= 0) {
              setCell(g, x, y, MATERIALS.EMPTY);
            } else {
              setCell(g, x, y, MATERIALS.FIRE, { fireTicks: ticks });
              for (const n of neighbors(x, y)) {
                if (isBlocked(g, x, y, n.x, n.y)) continue;
                const nb = getCell(g, n.x, n.y);
                if (nb.material === MATERIALS.GAS) {
                  setCell(g, n.x, n.y, MATERIALS.FIRE, { fireTicks: 6 });
                }
              }
            }
          }
        }
      }
    }

    function moveEnemies() {
      const g = state.grid;
      const updated = [];
      for (const enemy of state.enemies) {
        const { x, y, dir } = enemy;
        const nx = x + dir;
        if (!isBlocked(g, x, y, nx, y) && getCell(g, nx, y).material === MATERIALS.EMPTY) {
          setCell(g, nx, y, MATERIALS.ENEMY, { dir });
          setCell(g, x, y, MATERIALS.EMPTY);
          updated.push({ x: nx, y, dir });
        } else {
          const ndir = -dir;
          updated.push({ x, y, dir: ndir });
        }
      }
      state.enemies = updated;
    }

    function bfsPath(start, goal) {
      const g = state.grid;
      const queue = [start];
      const visited = new Set([`${start.x},${start.y}`]);
      const parent = {};
      while (queue.length) {
        const current = queue.shift();
        if (current.x === goal.x && current.y === goal.y) break;
        for (const n of neighbors(current.x, current.y)) {
          const key = `${n.x},${n.y}`;
          if (visited.has(key) || isBlocked(g, current.x, current.y, n.x, n.y)) continue;
          const cell = getCell(g, n.x, n.y);
          if ([MATERIALS.EMPTY, MATERIALS.TREASURE, MATERIALS.STONE].includes(cell.material)) {
            visited.add(key);
            parent[key] = current;
            queue.push(n);
          }
        }
      }
      const key = `${goal.x},${goal.y}`;
      if (!parent[key] && !(start.x === goal.x && start.y === goal.y)) return [];
      const path = [];
      let cur = goal;
      while (!(cur.x === start.x && cur.y === start.y)) {
        path.unshift(cur);
        cur = parent[`${cur.x},${cur.y}`];
      }
      return path;
    }

    function moveHero() {
      const path = bfsPath(state.hero, state.treasure);
      if (!path.length) return;
      const nextStep = path[0];
      const cell = getCell(state.grid, nextStep.x, nextStep.y);
      if ([MATERIALS.LAVA, MATERIALS.FIRE, MATERIALS.ENEMY].includes(cell.material)) {
        state.lost = true;
        return;
      }
      setCell(state.grid, state.hero.x, state.hero.y, MATERIALS.EMPTY);
      state.hero = { ...nextStep };
      setCell(state.grid, state.hero.x, state.hero.y, MATERIALS.HERO);
    }

    function checkGameEnd() {
      const heroCell = getCell(state.grid, state.hero.x, state.hero.y);
      if ([MATERIALS.LAVA, MATERIALS.FIRE, MATERIALS.ENEMY].includes(heroCell.material)) {
        state.lost = true;
      }
      if (state.hero.x === state.treasure.x && state.hero.y === state.treasure.y) {
        state.won = true;
        const reward = 10 + Math.floor(state.levelIndex / 10);
        state.coins += reward;
        state.stars += 1;
        saveProgress();
      }
      if (state.movesUsed > state.moveLimit) {
        state.lost = true;
      }
    }

    function applyHint() {
      if (state.coins < state.hintCost) {
        statusText.textContent = 'Nicht genug Coins für einen Hint!';
        return;
      }
      state.coins -= state.hintCost;
      statusText.textContent = 'Empfohlene Zugreihenfolge hervorgehoben.';
      hintBox.classList.add('flash');
      setTimeout(() => hintBox.classList.remove('flash'), 1000);
      saveProgress();
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / CELL);
      const y = Math.floor((e.clientY - rect.top) / CELL);
      const grid = state.grid;
      // check horizontal pins near click
      for (const pin of state.pins) {
        if (pin.pulled) continue;
        if (pin.orientation === 'h') {
          if (Math.abs((pin.y + 1) * CELL - y * CELL) < CELL / 2 && Math.abs((pin.x + 0.5) * CELL - x * CELL) < CELL) {
            pullPin(pin.id);
            return;
          }
        } else {
          if (Math.abs((pin.x + 1) * CELL - x * CELL) < CELL / 2 && Math.abs((pin.y + 0.5) * CELL - y * CELL) < CELL) {
            pullPin(pin.id);
            return;
          }
        }
      }
    });

    btnReset.addEventListener('click', () => resetLevel());
    btnHint.addEventListener('click', () => applyHint());
    btnNext.addEventListener('click', () => {
      if (state.levelIndex < LEVEL_COUNT) {
        state.levelIndex += 1;
        resetLevel();
        saveProgress();
      }
    });

    loadProgress();
    resetLevel();
    tick();
  </script>
</body>
</html>
